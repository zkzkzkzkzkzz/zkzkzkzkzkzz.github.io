---
title: "전화번호 목록"

categories:
  - Hash
tags:
  - CodingTest
  - Programmers
permalink: /CodingTest/Hash/solve-001/

toc: true
toc_sticky: true

date: 2025-08-28
last_modified_at: 2025-09-01
---


## 문제

[전화번호 목록](https://school.programmers.co.kr/learn/courses/30/lessons/42577)

<img alt="image" src="https://github.com/user-attachments/assets/8f7e3984-2673-4f21-a3f0-638645cfc4a5" />

## 문제 풀이

```cpp
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

bool solution(vector<string> phone_book) {
    bool answer = true;
    
    sort(phone_book.begin(), phone_book.end());
    
    for (int i = 0; i < phone_book.size() - 1; ++i)
    {
        string firstStr = phone_book[i];
        string secondStr = phone_book[i + 1];
        
        bool b = true;
        
        for (int j = 0; j < firstStr.size(); ++j)
        {
            if (firstStr[j] != secondStr[j])
            {
                b = false;
                break;
            }
        }
        
        if (b)
            return false;
    }
    
    return answer;
}
```

주어지는 번호는 int값이 아니라 문자열이기 때문에, 정렬시킬 경우 사전식으로 정렬되게 된다.\
예를 들어, {200, 10001, 100}이 입력되었을 때, {100, 200, 10001}이 아니라 {100, 10001, 200}으로 정렬된다.\
따라서, 인접한 두 문자열만 비교하여 접두사로 가지고 있는지 판단하면 된다.

다만 두 문자열을 비교하는 부분에서 효율성 테스트는 다음과 같이 나왔다.

<img alt="image" src="https://github.com/user-attachments/assets/8b18d66c-481a-467c-b832-6a177b69950e" />

문자를 앞에서부터 하나씩 비교해나가는 방식을 처음에 사용했는데, 이를 `std::string::compare(pos, count, str)` 메서드로 치환할 수 있었다.

```cpp
for (int i = 0; i < phone_book.size() - 1; ++i)
{
    string firstStr = phone_book[i];
    string secondStr = phone_book[i + 1];
    
    if (secondStr.size() >= firstStr.size() && secondStr.compare(0, firstStr.size(), firstStr) == 0)
        return false;
}
```

secondStr의 pos부터 pos+count까지 firstStr과 비교하여 같은지 비교하는 함수로, 접두사를 판별하는 것이기 때문에 가능한 방법이다.\
이 방식으로 바꾸니 근소하지만 좀 더 빨라지는 걸 확인할 수 있었다.

<img alt="image" src="https://github.com/user-attachments/assets/7c713908-c260-4a79-8a41-afaf0c6a79bb" />
