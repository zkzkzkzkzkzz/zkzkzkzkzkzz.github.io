---
title: "베스트앨범"

categories:
  - Hash
tags:
  - CodingTest
  - Programmers
permalink: /CodingTest/Hash/solve-003/

toc: true
toc_sticky: true

date: 2025-09-02
last_modified_at: 2025-09-02
---

## 문제

[베스트앨범](https://school.programmers.co.kr/learn/courses/30/lessons/42579)

<img alt="image" src="https://github.com/user-attachments/assets/2febe125-92a1-4f59-b440-30d46bd65941" />

## 문제 풀이

발상 자체는 금방 떠올랐는데 구현에 있어 이상하게 애먹었던 문제였다.\
먼저 장르별 총 재생 수를 구해서 우선순위를 구하고, 장르별로 모듈화한 해시맵을 이용해 답을 구하는 방식으로 진행했다.

```cpp
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

struct album
{
    int play;
    int idx;
};

vector<int> solution(vector<string> genres, vector<int> plays) {
    vector<int> answer;
    
    unordered_map<string, int> totalPlays;
    unordered_map<string, vector<album>> Songs;
    
    for (int i = 0; i < genres.size(); ++i)
    {        
        totalPlays[genres[i]] += plays[i];
        Songs[genres[i]].push_back({plays[i], i});
    }
    
    for (auto& [g, vec] : Songs)
    {
        sort(vec.begin(), vec.end(),
             [](const album& a, const album& b)
             {
                 if (a.play == b.play) return a.idx < b.idx;
                 return a.play > b.play;
             });        
    }
    
    vector<pair<string,int>> order(totalPlays.begin(), totalPlays.end());

    sort(order.begin(), order.end(),
         [](const auto& a, const auto& b){
             if (a.second != b.second) return a.second > b.second;
             return a.first < b.first;
         });
    
    
    for (auto& [genre, i] : order)
    {
        for (int i = 0, k = 0; i < Songs[genre].size() && k < 2; ++i, ++k)
        {
            answer.push_back(Songs[genre][i].idx);
        }
    }
    
    
    return answer;
}
```

모듈화를 위해 album 구조체를 생성하여 재생수와 인덱스를 가지고 있게 했고, 정렬은 재생 수 기준으로 내림차순, 재생 수가 같을 경우 인덱스 기준으로 하도록 람다함수를 이용했다.\
다만 처음에 총 재생 수를 해싱한 걸 unordered_map은 정렬이 안되다보니 어떻게 정렬해야 되는지 생각이 안나서 시간을 잡아먹었는데, 그냥 단순하게 벡터를 이용해서 추가로 정렬하면 되는 거였다.\
너무 한 번에 모든 기능을 퉁치려는 나쁜 습관이 아직도 남아있는 듯 하다.

기억이 가물가물해서 cmp로도 정렬을 해봤다.

```cpp
bool cmp(const album& a, const album& b)
{
    if (a.play == b.play)
        return a.idx < b.idx;
    
    return a.play > b.play;
}

vector<int> solution(vector<string> genres, vector<int> plays) {
    vector<int> answer;
    
    unordered_map<string, int> totalPlays;
    unordered_map<string, vector<album>> Songs;
    
    for (int i = 0; i < genres.size(); ++i)
    {        
        totalPlays[genres[i]] += plays[i];
        Songs[genres[i]].push_back({plays[i], i});
    }
    
    for (auto& [g, v] : Songs)
    {
        sort(v.begin(), v.end(), cmp);
    }

    // 이하 동일...
}
```
