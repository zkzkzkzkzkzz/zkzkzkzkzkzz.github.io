---
title: "트릭컬 스켈레톤 애니메이션"
excerpt: "Spine-Unity 패키지를 이용한 트릭컬 스켈레톤 애니메이션"

categories:
  - Unity

permalink: /Unity/trickcal/

toc: true
toc_sticky: true

date: 2025-08-20
last_modified_at: 2025-08-20
---

포폴 대비 단편적인 기능 구현 연습도 해볼겸 트릭컬 에셋으로 라투디를 시도해봤다.\
라투디는 보통 Spine을 이용하던데 유료다보니 이것저것 찾아보다 유니티 패키지를 하나 찾아냈다.\
처음엔 'Spine-Unity 패키지' 4.2버전을 받았었는데 트릭컬 에셋 열어보려 하니까 버전이 안맞는다고 4.1로 내리라 하더라.\
에셋 자체도 유니티 게임이다보니 AssetStudioGUI로 쉽게(?) 뜯긴 했는데 트릭컬이 나무위키에 적힌 거랑 다르게 버전업을 했는지, 에셋스튜디오도 버전업이 필요했음.

## SkeletonDataAsset


<img alt="스크린샷 2025-08-20 231543" src="https://github.com/user-attachments/assets/b037568a-d377-42b1-831f-95f1214ca9d2" />

임포트한 패키지를 통해 에셋을 살펴보니 기본적으로 에셋에 스킨이랑 애니메이션 정보가 다 들어가 있었다.\
이대로 -완-칠 순 없으니 외부 버튼으로 조작할 수 있도록 해보기로 했다.

<br>

## Skeleton Animation

추출한 에셋은 전투가 아니라 로비, 스토리 등에 이용되는 스탠딩 일러였기 때문에 감정표현 애니메이션 클립이 들어있었는데, 대부분은 두 개 이상의 클립을 가지고 있었다.\
그래서 '사도면접'처럼 감정표현별로 클립을 그룹화해서 하나의 버튼으로 여러 애니메이션을 재생할 수 있도록 했다.

### 애니메이션 그룹화

하나의 감정표현이 여러 개의 클립을 들고있을 수 있으니 List보단 Dictionary로 관리하기로 했다.

```cs
Dictionary<string, List<string>> Clips = new Dictionary<string, List<string>>()

private void BuildGroups()
{
    Clips.Clear();
    var data = dataAsset.GetSkeletonData(true);
    if (data == null) return;

    for (int i = 0; i < data.Animations.Count; ++i)
    {
        string clip = data.Animations.Items[i].Name;
        string key = ExtractPrefix(clip);

        if (!Clips.TryGetValue(key, out var list))
        {
            list = new List<string>();
            Clips[key] = list;
        }
        list.Add(clip);
    }
}
```


### 접두사 추출

<img alt="스크린샷 2025-08-20 231836" src="https://github.com/user-attachments/assets/ee7428a2-bd35-4c16-b3a1-e34b90c29384" />

클립은 **{상태}_{번호}**의 규칙을 가지고 있었기 때문에, _를 찾아서 그 앞까지 문자열을 추출하여 Dictionary의 Key로 설정했다. 

```cs
private string ExtractPrefix(string name)
{
    if (string.IsNullOrEmpty(name)) return "";

    int i = name.IndexOf('_');
    return (i > 0) ? name.Substring(0, i) : name;
}
```


### 애니메이션 사이클

![cycle](https://github.com/user-attachments/assets/0663caf4-b7ae-4fb0-bd78-9f5088f9d3c2)

일단 지금은 버튼을 누르면 차례대로 재생되도록 했다.\
마지막 애니메이션이 재생되면 그 다음은 처음으로 돌아오도록 구현했다.

```cs
public void CycleState(string stateKey)
{
		Clips.TryGetValue(stateKey, out var clips);
		int nextIdx = NextIdx.TryGetValue(stateKey, out var savedIdx) ? savedIdx : 0;
		
		string clip = clips[nextIdx];
		animState.SetAnimation(0, clip, loop);
		
		curStateKey = stateKey;
		lastClipIdx = nextIdx;
	
		NextIdx[stateKey] = (nextIdx + 1) % clips.Count;
}
```

## 스킨

<img alt="스크린샷 2025-08-20 232936" src="https://github.com/user-attachments/assets/73d50e40-de78-43f1-aae5-8b606c001510" width = "30%"/>

- default

<img alt="스크린샷 2025-08-20 232956" src="https://github.com/user-attachments/assets/dca99a74-7cb8-4e17-8a77-8e97ab971dab" width = "30%"/>

- Normal

<img alt="스크린샷 2025-08-20 233009" src="https://github.com/user-attachments/assets/29f5f522-07f8-4995-8a3f-1a071ca6541d" width = "30%"/>

- Gun


스킨이라 적혀있긴 했지만 타입이나 버전에 더 가까운 느낌이다.\
버터의 경우, 'default, Normal, Gun' 이렇게 세 종류를 가지고 있었다.

```cs
public void ApplySkin(string skinName)
{
    var data = skeleton.Data;
    Skin skin = data.FindSkin(skinName);

    if (skin == null) return;

    skeleton.SetSkin(skin);
    skeleton.SetSlotsToSetupPose();
    animState?.Apply(skeleton);
    
    curSkinIdx = Mathf.Max(0, skinNames.IndexOf(skin.Name));
}

public void SetSkin(string skinName) => ApplySkin(skinName);
```

<br>

## 상호작용

트릭컬하면 떠오르는 건 당연 **볼 당기기**일 것이다.\
볼을 클릭하고 옆으로 드래그하면 볼이 늘어나고 떼면 탱!하면서 돌아가는 상호작용을 구현해봤다.

### 볼 당기기

![cheek](https://github.com/user-attachments/assets/5250fdeb-b775-4919-bbbc-12f8995000bf)

#### 마우스 클릭

볼 당기기는 '볼을 클릭 -> 클릭한 채로 옆으로 드래그 -> 마우스 떼기'의 순서로 이루어진다.\
먼저 클릭 부분이다.

```cs
if (Input.GetMouseButtonDown(0))
{
    Vector3 sp = Input.mousePosition;
    sp.z = Mathf.Abs(cam.transform.position.z - transform.position.z);
    Vector2 world = cam.ScreenToWorldPoint(sp);

    bool overCheek = false;
    var hits = Physics2D.OverlapPointAll(world);
    for (int i = 0; i < hits.Length; i++)
    {
        if (hits[i] == cheekCollider) { overCheek = true; break; }
    }

    dragging = overCheek && InteractionCapture.TryBegin(InteractionCapture.Owner.Cheek);

    hasTarget = false;
    returning = false;

    if (dragging)
    {
        originLocal_bone = new Vector2(bone.X, bone.Y);

        if (followers != null)
        {
            for (int i = 0; i < followers.Length; i++)
            {
                var fb = followers[i]; if (fb.bone == null) continue;
                fb.originLocal = new Vector2(fb.bone.X, fb.bone.Y);

                float wx = fb.bone.WorldX, wy = fb.bone.WorldY;
                fb.originWorld = new Vector2(wx, wy);
            }
        }

        state.SetAnimation(0, touchAnim, true);

        if (waitEndCo != null) { StopCoroutine(waitEndCo); waitEndCo = null; }
        if (audioSource && audioSource.isPlaying) audioSource.Stop();
    }
}
```

InteractionCapture는 후술할 소유권 판정 스크립트로 정해진 영역에서만 볼 당기기 상호작용이 작동하도록 하기 위함이다.\
미리 배치한 콜라이더를 이용하여 마우스 클릭이 들어왔는지 판별한다.

#### 마우스 드래그

```cs
if (dragging && Input.GetMouseButton(0))
{
    Vector3 sp = Input.mousePosition;
    sp.z = Mathf.Abs(cam.transform.position.z - transform.position.z);
    Vector3 world = cam.ScreenToWorldPoint(sp);

    Vector3 skel = skeletonAnimation.transform.InverseTransformPoint(world);

    float lx, ly;
    var parent = bone.Parent;
    if (parent != null) parent.WorldToLocal(skel.x, skel.y, out lx, out ly);
    else { lx = skel.x; ly = skel.y; }

    targetLocal_bone = new Vector2(lx, ly);
    hasTarget = true;
}
```

마우스의 드래그 위치를 따라서 본이 움직인다.\
Spine에서 각 본의 X, Y는 자신의 바로 윗 부모 본 기준 로컬값으로 저장되므로, `bone.parent`를 꺼내고, 부모가 존재하면 부모 본 로컬 좌표로 변환한다.\
루트 본이라서 부모가 없다면 바로 값을 적용한다.

#### 마우스 떼기

```cs
if (Input.GetMouseButtonUp(0))
{ 
    if (dragging)
    {
        returning = true;
        EndTouch();
    }

    hasTarget = false;
    InteractionCapture.End(InteractionCapture.Owner.Cheek);
}
```

마우스를 떼면 해당 상호작용을 끝내고 다시 Idle로 돌아간다.


#### 본 이동

볼을 당기거나 마우스를 떼 다시 돌아갈 때 본의 이동이 필요하다.\
`ApplyCheekPose`는 본 좌표를 계산하는 함수롤 `Start`에서 구독해두었다.

UpdateLocal은 Spine-Unity가 제공하는 ISkeletonAnimation 인터페이스의 이벤트로,
매 프레임 내부 파이프라인에서 애니메이션 상태를 적용한 직후와 스켈레톤의 월드 변환을 계산하기 전 사이에 이 이벤트를 호출한다.

```cs
void Start()
{
    skeletonAnimation.UpdateLocal += ApplyCheekPose;
}

void OnDisable()
{
    if (skeletonAnimation != null)
        skeletonAnimation.UpdateLocal -= ApplyCheekPose;
}
```

<details>
<summary>ApplyCheekPose 함수</summary>
<div markdown="1">

```cs
void ApplyCheekPose(ISkeletonAnimation _)
{
    if (bone == null) return;

    if (dragging && hasTarget)
    {
        Vector2 deltaLocal = targetLocal_bone - originLocal_bone;
        float max = maxDragDist;
        if (deltaLocal.sqrMagnitude > max * max)
            deltaLocal = deltaLocal.normalized * max;

        float owx, owy, dwx, dwy;
        var parent = bone.Parent;
        if (parent != null)
        {
            parent.LocalToWorld(originLocal_bone.x, originLocal_bone.y, out owx, out owy);
            parent.LocalToWorld(originLocal_bone.x + deltaLocal.x, originLocal_bone.y + deltaLocal.y, out dwx, out dwy);
        }
        else
        {
            owx = originLocal_bone.x; owy = originLocal_bone.y;
            dwx = originLocal_bone.x + deltaLocal.x; dwy = originLocal_bone.y + deltaLocal.y;
        }
        Vector2 worldDelta = new Vector2(dwx - owx, dwy - owy);

        bone.X = originLocal_bone.x + deltaLocal.x;
        bone.Y = originLocal_bone.y + deltaLocal.y;

        if (followers != null)
        {
            for (int i = 0; i < followers.Length; i++)
            {
                var fb = followers[i]; if (fb.bone == null) continue;
                Vector2 targetWorld = fb.originWorld + worldDelta * Mathf.Clamp01(fb.weight);

                float lx, ly;
                var p = fb.bone.Parent;
                if (p != null) p.WorldToLocal(targetWorld.x, targetWorld.y, out lx, out ly);
                else { lx = targetWorld.x; ly = targetWorld.y; }

                fb.bone.X = lx;
                fb.bone.Y = ly;
            }
        }
        return;
    }

    if (returning)
    {
        Vector2 curLocal = new Vector2(bone.X, bone.Y);
        Vector2 nextLocal = Vector2.Lerp(curLocal, originLocal_bone, Time.deltaTime * returnSpeed);
        bone.X = nextLocal.x;
        bone.Y = nextLocal.y;

        if (followers != null)
        {
            for (int i = 0; i < followers.Length; i++)
            {
                var fb = followers[i]; if (fb.bone == null) continue;

                Vector2 curWorld = new Vector2(fb.bone.WorldX, fb.bone.WorldY);
                Vector2 nextWorld = Vector2.Lerp(curWorld, fb.originWorld, Time.deltaTime * returnSpeed);

                float lx, ly;
                var p = fb.bone.Parent;
                if (p != null) p.WorldToLocal(nextWorld.x, nextWorld.y, out lx, out ly);
                else { lx = nextWorld.x; ly = nextWorld.y; }

                fb.bone.X = lx;
                fb.bone.Y = ly;
            }
        }

        if ((nextLocal - originLocal_bone).sqrMagnitude <= returnStopDist * returnStopDist)
        {
            bone.X = originLocal_bone.x;
            bone.Y = originLocal_bone.y;
            returning = false;

            if (followers != null)
            {
                for (int i = 0; i < followers.Length; i++)
                {
                    var fb = followers[i]; if (fb.bone == null) continue;

                    float lx, ly;
                    var p = fb.bone.Parent;
                    if (p != null) p.WorldToLocal(fb.originWorld.x, fb.originWorld.y, out lx, out ly);
                    else { lx = fb.originWorld.x; ly = fb.originWorld.y; }

                    fb.bone.X = lx;
                    fb.bone.Y = ly;
                }
            }
        }
    }
}
```

</div>
</details>

### 쓰다듬기

![pat](https://github.com/user-attachments/assets/8f9bc6ff-b221-4a72-acea-247459a6d31d)

트릭컬에는 볼 당기기 외에도 머리를 쓰다듬는 상호작용이 있다.\
사도의 머리 윗부분을 마우스로 좌우로 드래그하면 쓰다듬기 상호작용이 작동한다.

구조는 볼 당기기와 동일하다.\
차이가 있다면 임계점을 두어 좌우로 드래그한 길이가 해당 임계점을 넘길 때에만 작동하도록 구현했다.

```cs
if (captured && Input.GetMouseButton(0))
{
    var cur = (Vector2)Input.mousePosition;
    totalX += Mathf.Abs(cur.x - lastMousePos.x);
    lastMousePos = cur;

    if (!patActive && totalX >= PatThreshold)
        StartPat();
}
```


